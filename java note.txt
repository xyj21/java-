标识符：标识符命名规则：只能由数字、字母、下划线、$符号构成
标识符可以含有中文
标识符不能以数字开始
标识符不能使用关键字
严格区分大小写
理论上没有长度限制
标识符可以标识什么：类名、接口名、方法名、变量名、常量名
标识符命名规范：统一风格
见名知意
驼峰命名
类名接口名：首字母大写，后边每个单词首字母大写
变量名和方法名：首字母小写，后边每个单词首字母大写

 字面量就是数据

1.关于变量的分类：
	在方法体当中声明的变量：局部变量
	在方法体之外，类体内声明的变量：成员变量
	重点依据是：声明的位置
变量三要素：数据类型、变量名、值
变量必须先声明再赋值才能访问
2.注意：局部变量只在方法体当中有效，方法体执行结束，该变量内存释放
3.变量的作用域：
	什么是作用域变量的有效范围
	作用域：出了大括号就不认识了
	同一个域中不能有同名变量
	两个不同的域可以
	Java中有一个很重要的原则：就近原则，哪个近就访问谁
	for(int n=0;n<10;n++)这里的n只属于for域
	出了for外不能访问
int a,b,c = 100;
c赋值100，a和b没赋值
声明和赋值可以分开，也可以一起做
赋值运算符“=”右边的，只能是：整数型、浮点型、布尔型、字符型、字符串型其中的一个，不能随便写
数据类型：
	数据类型用来声明变量，程序在运行过程中根据不同的数据类型分配不同大小的空间
	数据类型分为两种：
		第一种：基本数据类型
		基本数据类型又可以划分为4大类8小种
			第一类：整数型（没有小数的）：byte,short,int,long
			第二类：浮点型（有小数）：float,double
			第三类：布尔型：只有两个值：true，false：boolean
			第四类：字符型：Java中规定字符型字面量必须使用单引号括起来，属于文字：char
		
		8小种：byte,short,int,long
		float,double
		boolean
		char
		第二种：引用数据类型
			字符串型String属于引用数据类型
			String字符串不属于基本数据类型范畴
			Java中除了基本数据类型外，剩下的都是引用数据类型
			引用数据类型后期面向对象的时候才会接触
	十进制转换二进制：方法：除以二，然后余数逆序输出
	（一个字节）byte类型的取值范围：-128~127    		共256个数字
	计算方法：byte是一个字节，八个比特位，则可以存储的最大值是：01111111
	注意：在计算机当中，一个二进制位最左边的是符号位，当为0时表示正数，当为1时表示负数
	（两个字节）short -32768~32767	可以表示65536个不同的数字
	（四个字节）int -2147483648~2147483647
	（两个字节）char 0~65535   可以表示65536个不同的数字
	short和char实际上容量相同，不过char可以表示更大的数字，char表示文字，没有正负之分，所以char可以表示更大的数字
	System.out.println与System.out.print的区别：System.out.println结尾自带换行，System.out.print后边无换行
	\t制表符输出后相当于加了一个Tab键
	\u表示后面的是一个字符的unicode编码
	char x = '\u4e2d';    4e2d是'中'
	十六进制满十六进一：
	1 2 3 4 5 6 7 8 9 a b c d e f 10 11 12 13 14 15 16 17 18 19 1a 1b.....
	在任何情况下，整数型的“字面量/数据”默认被当作int类型处理。
	如果希望该“整数型字面量”被当作long类型来处理，需要在“字面量”后面添加L/l（建议使用大写）
	long e = 2147483648（默认被当作int看待）;
	整数型字面量一上来编译器会把它当作int类型
	会报错，int最大2147483647
	e是long类型，完全可以容纳2147483648，但是2147483648本身超出了int范围
	错误：整数太大
	怎么解决：在后边加一个L
	1.小容量可以直接赋值给大容量，称为自动类型转换
	Java语言中，大容量赋值给小容量报错：不兼容的类型：从long到int可能会有损失
	2.大容量转换成小容量，要想编译通过，必须加强制类型转换符，进行强制类型转换
	但需要注意的是：加强制类型转换符之后，虽然编译通过，但运行时可能会损失精度
	Java中有一个语法规则：
		当这个整数型字面量没有超出byte的取值范围，那么这个整数型字面量可以直接赋值给byte类型的变量
	3.在类型转换时需要遵循那些规则：
	第一条：八种基本数据类型中，除Boolean类型不能转换，剩下七种类型之间都可以相互转换
	第二条：如果整数型字面量没有超出byte,short,char的取值范围，可以直接将其赋值给byte,short,char类型的变量
	第三条：小容量向大容量转换称为自动类型转换，容量从小到大的排序为byte,short(char),int,long,float,double,其中short和char都占用两个字节，
	但是char可以表示更大的正整数
	第四条：大容量转换成小容量，称为强制类型转换，编写时必须添加"强制类型转换符"，但运行时可能出现精度损失，谨慎使用
	第五条：byte,short,char类型混合运算时，先各自转换成int类型再做运算
	第六条：多种数据类型混合运算，各自先转换成容量最大的那一种再做运算
怎样接收用户键盘输入：
	java.util.Scanner s = new java.util.Scanner(System.in);
	int i = s.nextInt();//接收整数
	String str = s.next();//接收字符串
	控制语句的出现可以让我们的程序更具逻辑性/条理性，可以使用控制语句实现一个业务了
控制语句包括几类：
	选择语句（分支语句）、循环语句、转向语句
		选择语句：if语句、switch语句
		循环语句：循环反复去执行某段特定的代码块
		for循环、while循环、do...while循环
		转向语句：break语句、continue语句、return
关于循环语句
	for
	 while 
	 do...while
	什么是循环语句，为什么要使用：因为在现实世界中，有很多事情需要反复/重复去做
	如果有一块代码需要重复执行，此时为了减少代码量，使用循环语句
	关于转向语句：
	  break;
	  continue;
	  return;
方法：1.方法是什么：方法是可以完成某个特定功能的，并且可以被重复利用的代码片段
一般一个方法就是一个“功能单元”
在开发中如果某个功能是可以独立抽取出来的，建议定义为方法
以后只要需要这个功能，那么直接调用这个方法即可，而不需要重复编写业务逻辑代码
JVM中主要的三块内存空间：栈、堆、方法区        当然，除了这三块还有其他的
类加载器classloader，将硬盘上的xxx.class字节码文件装载到JVM的时候，会将字节码文件存放到方法区当中
方法区存储的是代码片段
类需要加载，所以方法区当中最先有数据
方法重载（overload）：
什么时候需要考虑使用方法重载：在同一个类当中，如果”功能一“和”功能二“的功能是类似的，那么可以考虑将他们的方法名一致，这样既美观，也便于后期代码编写
注意：方法重载不能随便使用，如果两个功能不相干，此时使用方法重载，会导致编码更麻烦
什么时候代码会发生方法重载：
条件1：在同一个类当中
条件2：方法名相同
条件3：参数列表不同
    参数的个数不同算不同
    参数的顺序不同算不同
    参数的类型不同算不同
方法重载和方法的"返回值类型"无关
方法重载和方法的"修饰符列表"无关
使用方法重载机制优点：
    优点一：代码整齐美观
    优点二：”功能相似“的，可以让方法名相同，更易于以后方法编写
    Java语言中，如何进行区分的：首先Java编译器会通过方法名进行区分，但是在Java语言中允许方法名相同的情况出现，
    如果方法名相同的情况下，编译器会通过方法的参数类型进行区分
	关于Java中的浮点型数据：
    浮点型包括：float(4byte)单精度  double(8byte)双精度
    double更精确
    在有些情况下double的精度也是远远不够的，Java提供了一种精度:java.math.BigDecimal(不是基本数据类型，
    属于引用数据类型)
    float和double存储的都是近似值：因为现实世界中有无限循环数据，但是计算机的内存有限，用一个有限的资源存储无限的数据，只能存取近似值
    long类型占用8个字节，float占用4个字节，float容量大
    任意一个浮点型数据都比整数型空间大
    Java中规定，任何一个浮点型数据，默认被当作double处理
    如果想让这个浮点型字面量被当作float类型处理，那么在字面量后边加上F/f
	if语句的语法结构以及运行原理
    if语句的语法格式：
    第一种写法：if(布尔表达式){
    java语句;
    java语句;
    }
    这里的{}叫做一个分支
    如果布尔表达式中的结果是true，则执行大括号中的程序
    第二种写法：
     if(布尔表达式){
     Java语句;//分支1
     }
     else{
     java语句;//分支2
     }
     执行原理：如果布尔表达式的结果是true。则执行表达式1，分支2不执行
     如果布尔表达式的结果是false。则执行表达式2，分支1不执行
     以上语句可以保证一定会有一个分支执行
    注意：对于if语句来说，在任何情况下只能有一个语句执行，不可能存在大于1个分支执行，
    if语句中只要有一个分支执行了，整个if语句结束
    第三种写法：
    if(布尔表达式1){
    Java语句;
    }
    else if(布尔表达式2){
    Java语句;
    }
    else if(布尔表达式3){
    Java语句;
    }
    else if(布尔表达式4){
    Java语句;
    }
    执行原理：先判断布尔表达式1，如果为true，则执行分支1，然后if语句结束
    当布尔表达式1的结果是false，那么会继续判断布尔表达式2的结果，如果布尔表达式2的结果是true，则执行分支2，然后整个if结束
    从上往下依次判断，主要看第一个true发生在那个分支上，第一个true对应的分支执行，只要一个分支执行，整个if结束
    第四种写法:
     if(布尔表达式1){
    Java语句;
    }
    else if(布尔表达式2){
    Java语句;
    }
    else if(布尔表达式3){
    Java语句;
    }
    else if(布尔表达式4){
    Java语句;
    }
    else{
    java语句;}//以上条件都不成立则执行else
    Java语句只有一条时，大括号可以省略，但为了可读性，最好不要省略
    控制语句和控制语句是可以嵌套的，但嵌套的时候要一个语句一个语句进行分析，不要冗杂在一起分析
栈在方法被调用的时候，该方法需要的内存空间在栈中分配
一种非常经典的数据结构：栈
数据结构通常是存储数据的容器
而该结构可能存在不同的结构
常见数据结构：数组、链表、图、树、二叉树、栈、队列
Java语言把常用的数据结构已经写好了，直接用就行
和数据结构通常一起出现的是算法：排序、查找....
处于栈顶部的元素具备活跃权
栈中存储：方法运行过程中需要的内存，以及栈中会存储方法的局部变量
				面向对象：：：：
面向过程和面向对象有些什么区别：
	从语言方面出发 ： 对c语言：完全面向过程
					对c++：一半面向过程，一半面向对象（半面向对象
					Java：完全面向对象
	什么是面向过程/对象的开发方式：
	过程：注重步骤，注重的是实现这个功能的步骤
	另外面向过程也注重实现功能的因果关系
	面向过程有什么缺点/优点：
		面向过程最主要是每一步与每一步的因果关系，其中A步骤因果关系到B步骤，A和B联合起来形成一个子模块，子模块
		和子模块之间又因为因果关系结合到一起。假设其中任何一个因果关系出现问题（错误），此时整个系统的运转都会出现问题（代码和代码之间的耦合度太高，扩展力太差）
	优点：对于小型项目（功能），采用面向过程的方式进行开发，效率较高
	不需要前期进行对象的提取，模型的建立，采用面向过程的方式可以直接写代码（因果关系），从而实现功能
	采用面向对象的方式进行开发，更符合人类的思维方式（面向对象成为主流的原因）
	人类就是以“对象”的方式去认识世界的
	所以面向对象更容易让我们接受，就是将现实世界分割成不同的单元，然后每一个单元都实现成对象，然后驱动一下，让各个对象之间协作起来形成一个系统
	面向过程主要关注的是：实现步骤以及挣整个过程
	面向对象主要关注的是：对象A，对象B，对象C.....然后对象ABC组合，或者CBA组合
	OOA：面向对象分析
	OOD：面向对象设计
	OOP：面向对象编程
	整个软件开发过程，都是采用OO进行贯穿的
	实现一个软件的过程：分析（A）-->设计（D）-->编程（P）
	面向对象三大特征：封装、继承、多态
	任何一个面向对象的编程语言，都包括这三个特征
	类和对象的概念：
	面向对象当中最主要是对象
	什么是类：类实际上在现实世界当中是不存在的，是一个抽象的概念，是一个模板，是人类大脑进行
	思考、总结、抽象的一个结果
	类本质上是现实世界当中某些事物具有共同特征，将这些共同特征提取出来形成的
	概念就是一个“类”
	什么是对象：
	对象是实际存在的个体
	在Java语言中，要想得到“对象”，必须先定义“类”，“对象”是通过“类”这个模板创造出来的
	类就是一个模板：类中描述的是所有对象的“共同特征信息”
	对象就是通过类创建的个体
	对象还有另外一个名称：实例
	通过类创建对象的过程我们可以称为：创建，也可以称为：实例化
	类是描述共同特征的一个模板
	类 = 属性 + 方法
	属性来源于状态
	方法来源于动作
	怎么定义一个类，语法格式：
		{修饰符列表} class 类名{
			//类体 = 属性 + 方法
		}
	属性在代码上以“变量”的形式存在：因为属性对性的是“数据”
	修饰符列表可以省略
	关于编译的过程：
	按理说应该先编译XueSheng.java，然后再编译XueShengTest.java，但是对于
	编译器来说，编译XueShengTest.java文件的时候，会自动找XueSheng.class，如果没有，会自动编译XueSheng.java文件
	生成XueSheng.class文件
	凡是通过new运算符创建的对象，都存储在堆内存当中
	new运算符的作用就是在堆内存中开辟一块空间
	栈的活动最频繁，一直压栈弹栈
	对象存储在堆内存当中
	对于成员变量来说，没有手动赋值时，系统默认赋值
	赋的值都是默认值
	Boolean是false，char是\u0000，字符串是null,其他都是0
	什么是实例变量：实例变量实际上就是：对象级别的变量
	Student s1 = ...  像s1这种变量，保存了对象内存地址的变量，有一个特殊的名字：引用
	实例变量一个对象一份
	访问实例变量：引用.实例变量名
	通过赋值“=”的方式将内存中实例变量的值修改
	对象和引用的区别：
	对象是通过new出来的，在堆内存中存储
	引用是：但凡是变量，并且该变量中保存了内存地址指向了堆内存当中的对象的(是存储对象内存地址的一个变量)
	引用不一定是局部变量
	程序在什么情况下会出现空指针异常：“空引用”访问实例/引用相关的数据时，都会出现空指针异常
	Java中规定，参数传递的时候，和类型无关，不管是基本数据类型还是引用数据类型，统一都是将盒子中保存的那个值
	复制一份，传递下去
	内存地址也是值，也是盒子中保存的一个东西
	程序在什么情况下会出现空指针异常：空引用访问“对象相关”的数据时
	方法在调用的时候参数是怎么传递的：实际上，在Java语言中，方法通过参数传递，和类型无关，都是将变量中保存的
	那个“值”传过去。
	构造方法：
		1.什么是构造方法：
		构造方法是一个比较特殊的方法，通过构造方法可以完成对象的创建，以及实例变量的初始化
		2.当一个类没有提供任何构造方法，系统会默认提供一个无参数的构造方法（这个构造方法被称为缺省构造器）
		3.使用new运算符来调用构造方法
		4.语法结构：
		【修饰符列表】 构造方法名 （形式参数列表）{
			构造方法体；
		}
		注意：
		①修饰符列表目前统一写public，不要写public static
	    ②构造方法名和类名必须一致
		③构造方法不需要指定返回值类型，也不能写void（写上void表示普通方法）
		④通常在构造方法体当中给属性赋值，完成属性的初始化
	构造方法作用：创建对象，并且创建对象的过程中给属性赋值（初始化）
	实例变量的赋值：在构造方法执行的过程中完成初始化的，完成赋值的。不是类加载的时候赋值的
	手动定义有参数的构造方法，无参数构造方法将消失。需要手动定义无参数构造方法
	对于实例变量来说，只要在构造方法中没有手动赋值，都会赋值成默认值
	封装：有了封装才有继承，有了继承才能说多态
	封装有什么用：第一个作用：保证内部结构的安全
	第二个作用：屏蔽复杂，暴露简单
	在代码级别上，封装有什么用呢：一个类体当中的数据，假设封装之后，对于代码的调用人员来说，不需要关心代码的复杂实现，
	只需要一个简单的入口就可以访问了。
	另外，类体中安全级别较高的数据封装起来，外部人员不能随意访问，来保证数据的安全性
	访问一个对象的属性，通常包括两种操作：一种是读数据，一种是该数据
	 优点：数据安全了，调用者方便
	 怎么进行封装：第一步：属性私有化（使用private关键字进行修饰）
	 第二步：对外提供简单的操作入口
	 private表示私有的，被这个关键字修饰以后，该数据只能在本类中访问
	 对外提供简单的访问入口，外部程序只能通过调用以下的代码来完成访问
    带有static的方法：通过“类名.”的方式访问
	不带static的方法被称为：实例方法（对象方法，对象级别的方法）
	（对象被称为实例）
	实例变量是对象变量，实例方法是对象方法
	封装第一步：属性私有化
	封装第二步：对外提供公开的set和get方法作为操作入口。并且都不带static，都是实例方法
	注意：
		Java开发规范中有要求，set方法和get方法要满足以下格式：
			get方法的要求：
			  public 返回值类型 get + 属性名首字母大写（无参）{
				  return xxx;
			  }
			set方法要求：
			  public void set + 属性名首字母大写（有1个参数）{
				  xxx = 参数;
			  }
	只有方法修饰列表中有static的时候，才能使用“类名.”的方式访问
this和static
static：1.static翻译为"静态的"
2.所有static关键字修饰的都是类相关的，类级别的
3.所有static修饰的，都采用“类名.”的方式访问
4.static修饰的变量：静态变量
5.static修饰的方法：静态方法
成员变量（方法体外）又可以分为：实例变量和静态变量
实例的（不带static）都是对象相关的，访问时采用“引用.”的方式访问。需要先new对象
静态的，都是类相关的，访问时采用“类名.”的方式访问。不需要new对象
什么时候变量声明成实例的，什么时候声明成静态的：
	如果这个类型的所有对象的某个属性值都是一样的，不建议定义为实例变量，浪费内存空间。建议
	定义为类别级特征，定义为静态变量，在方法区中只保留一份，节省内存开销
	一个对象一份的是实例变量
	所有对象一份的是静态变量
	实例的：一定使用“引用.”来访问
	静态的：建议使用“类名.”来访问，但使用“引用.”也行
	标准：当这个方法体当中直接访问了实例变量，这个方法一定是实例方法
	工具类当中的方法一般都是静态的
	使用static可以定义：静态代码块
	什么是静态代码块，语法是什么：
	static {
		java语句;
	}
	static静态代码块在什么时候执行呢：类加载时执行，并且只执行一次
	注意：静态代码块在类加载时执行，并且在main方法执行之前执行
	静态代码块不是每个类当中都要写的
	静态变量在静态代码块下边：错误：非法前向引用
	靠代码顺序来决定谁先谁后
	Java代码中有顺序要求的有哪些：
		第一：对于一个方法来说，方法体中的代码是有顺序的遵循自上而下的顺序执行
		第二：静态代码块1和静态代码块2是有先后顺序的
		第三：静态代码块和静态变量是有先后顺序的
	除了静态代码块之外，还有实例语句块
	this：1.是一个关键字，全部小写
		2.一个对象一个this
		this是一个变量，是一个引用  this保存当前对象的内存地址，指向自身
		所以严格意义上来说，this代表的就是“当前对象”
		this存储在堆内存当中，对象的内部
		3.this只能使用在实例方法中，谁调用这个实例方法，this就是谁。所以this代表的是：当前对象
		4.this大部分情况下是可以省略的
		5.为什么this不能使用在静态方法中：this代表当前对象，静态方法中不存在当前对象
	this可以使用在实例方法中，不能使用在静态方法中
	不可以省略this.的情况：this.no（属性名） = no（形式参数）    用来区分实例变量和局部变量
	this除了可以使用在实例方法中，还可以用在构造方法中
	新语法：通过当前的构造方法去调用另一个本类的构造方法，可以使用以下语法格式
	this（实际参数列表）
	作用：代码复用
	this（）这种语法只能出现在一个构造方法的第一行
	使用继承机制来解决代码复用问题
	继承作用：
		基本作用：子类继承父类，代码可以得到复用
		主要作用：因为有了继承关系，才有了后期方法覆盖和多态机制
	Java只支持单继承，不支持多继承
	可以Z继承Y，然后Y继承X
	一个父类可以被多个子类继承
	Java中规定：子类继承父类，除构造方法不能继承之外剩下都可以继承，但是私有的属性无法在子类中直接访问
	在Java中，如果没写继承任何类，默认继承object类
	继承缺点：会让代码的耦合度增强（修改父类子类也会受到牵连）
	子类继承父类之后，可以使用子类对象调用父类方法（其实是它自己的方法）
	本质上，子类继承父类之后，是将父类继承过来的方法归自己所有
	实际上调用的也不是父类的方法，是他子类自己的方法
	注意：当源码当中一个方法以“;”结尾，并且修饰符列表里有“native”关键字，表示底层调用c++
	写的dll程序（dll动态链接库文件）
	如果直接输出引用，println这个方法会自动调用引用的toString方法
	输出：类名@地址
	子类继承父类中，有一些“行为”可能不需要改进，有一些行为可能面临着必须改进
	因为父类中继承过来的方法已经无法满足子类的业务需求
	什么时候使用方法覆盖呢：子类继承父类之后，当继承过来的方法无法满足当前子类的业务需求时，
	子类有权利对这个方法进行重新编写，进行“方法覆盖”
	当子类对父类继承过来的方法重写之后，子类对象调用该方法重写后的方法
	怎样构成方法覆盖：
		条件一：两个类必须要有继承关系
		条件二：重写之后的方法和之前的方法具有：
			相同的返回值类型
			相同的方法名
			相同的形式参数列表
		条件三：访问条件不能更低，可以更高
		将public改为protected。错误：正在尝试分配更低的访问权限
		条件四：重写之后的方法不能比之前的方法抛出更多的异常，可以更少
		注意一：方法覆盖只是针对方法，与属性无关
		注意二：私有方法无法覆盖
		注意三：构造方法不能被继承，也不能方法覆盖
		注意四：方法覆盖只是针对于实例方法，静态方法覆盖没有意义
		关于Object类中的toString（）方法
		作用：将“Java对象”转换成“字符串”的形式
		cat基础语法：
			经过测试得知：Java中允许这样的语法：
			父类型的引用允许指向子类型的对象
	1.学习多态之前，需要普及两个概念：
	注意：无论是向上转型还是向下转型，两者之间必须有继承关系，没有继承关系编译器报错
	向上转型：子————父（自动类型转换）
	向下转型：父————子（强制类型转换，需要加强制类型转换符）
	多态表示多种形态：编译的时候是一种形态，运行的时候是另一种形态
	编译的时候编译器只知道a2的类型是Animal，所以编译器在检查语法的时候，会去Animal.class字节码文件中找move()
	方法，找到了，绑定上move()方法，编译通过，静态绑定成功
	运行阶段：在堆内存中创建的Java对象是cat对象，所以move的时候，真正参与的对象是cat，
	所以运行阶段会动态执行cat对象的move（）方法，这个过程属于运行阶段绑定（动态绑定）
	多态指的是：父类型引用指向子类型对象
	什么时候使用向下转型：当需要访问的是子类对象的“特有”的方法，此时必须进行向下转型
	不要随便做强制类型转换
	Animal a6 = new Bird（）；//编译器检测到a6这个引用是Animal类型
	而Animal和Cat之间存在继承关系，所以可以向下转型
	Cat y = (Cat)a6;
	 y.catchMouse();
	 运行阶段，堆内存实际创建的对象是：Bird对象
	 在实际运行过程中，拿着Bird对象转换成Cat对象就不行了。因为Bird和Cat之间没有继承关系
	 想要将Bird转换成Cat，两者之间没有继承关系，编译器就会报错
	 instanceof：
	 第一：instanceof可以在运行阶段动态判断引用指向的对象的类型
	 第二：instanceof的语法：
	 （ 引用 instanceof 类型）
	 第三：instanceof运算符的运算结果只能是：true/false
	
	 第四：c是一个引用，c变量保存了内存地址指向了堆中的对象
	 假设（c instanceof Cat）为false表示：c引用指向的堆内存中的Java对象不是一个Cat
	  假设（c instanceof Cat）为true表示：c引用指向的堆内存中的Java对象是一个Cat
	任何时候对类型进行向下转型时，一定要使用instanceof运算符进行判断
	多态的典型代码：父类型的引用指向子类型的对象
	多态在开发中的作用：降低程序的耦合度，提高程序的扩展力
	super关键字：
		super是一个关键字
		this：能出现在实例方法中和构造方法中，不能使用在静态方法中
		this.大部分情况下是可以省略的，在区分局部变量和实例变量时不能省略
		this（）只能出现在构造方法第一行，通过当前构造方法去调用“本类”中其他的构造方法，
		目的是：代码复用
		super能出现在实例方法和构造方法中
		super.和super（）
		super：能出现在实例方法中和构造方法中，不能使用在静态方法中
		super.大部分情况下是可以省略的，如果父类型当中和子类型当中有同名属性，并且希望对子类对象访问父类型属性，super不能省略
		父中有，子中也有，如果在子中访问父的特征，不能省略
		super（）只能出现在构造方法第一行，通过当前构造方法去调用“父类”中其他的构造方法，
		目的是：创建子类对象的时候，先初始化父类型特征
		super（）表示通过子类的构造方法调用父类的构造方法
		重要结论：
		当一个构造方法第一行：既没有this（）又没有super（）的话，默认会有一个super（）；
		表示通过当前子类的构造方法调用父类的无参数构造方法
		所以必须保证父类的无参数构造方法存在
		this（）和super（）不能共存，它们都是只能出现在构造方法的第一行
		Object类的无参数构造方法处于“栈顶部”
		栈顶的特点：最后调用，但是最先执行结束
		当父类属性为private时，无法在其它类中调用。
		使用super（实际参数）可以进行调用
		注意：虽然调用构造方法，在构造方法执行过程中一连串调用了父类的构造方法，父类的构造方法又继续向下
		调用了它的父类的构造方法，但是实际上对象只创建了一个
		super（）到底是干嘛的：super（）实参的作用：初始化当前对象的父类特征
		并不是创建新对象，实际上对象只创建了一个
		super关键字代表：super关键字代表的就是当前对象的那部分父类型特征
		super是this指向的那个对象中的一块空间
		子类中如果有未命名的属性，在构造方法中会赋默认值，this.属性为默认值
		如果在父类中赋值，super.会被赋值
		Java是怎么区分子类和父类的同名属性的：this.name        super.name
		super不是引用，也不保存内存地址，也不指向任何对象，只是代表指向当前父类对象的特征
		this和super不能使用在static静态方法中
		super.不仅可以访问属性，也可以访问方法 
		System.exit(0);//强行退出Java虚拟机
	1.关于Java集成开发环境：eclipse、intelliJ IDEA（主流）
	idea快捷键：输入main之后按Tab或者psvm直接生成main方法
	sout直接输出
	删除一行ctrl y
	窗口变大变小：ctrl shift F12
	alt + 标号可以切换窗口
	提示方法的参数：ctrl + p
	ctrl + d复制一行
	final:
		1.final是Java语言中的一个关键字
		2.表示最终的，不可变的
		3.可以修饰变量、方法、类......
		4.final修饰的变量：final修饰的局部变量一旦赋值，不能重新赋值
		引用也是一个变量
		final修饰的引用只能指向一个对象，并且它只能永远指向该对象，无法指向其他对象
		并且在该方法执行过程当中该引用指向对象之后，该对象不会被垃圾回收器回收
		直到当前方法结束，才会释放空间
		虽然final的引用指向对象A后，不能再重新指向对象B，但是对象A的数据可以修改
		该引用指向对象内部的数据是可以修改的
		final修饰的变量只能赋一次值
		final修饰的方法：final修饰的方法无法被覆盖，无法重写
		final修饰的类：final修饰的类无法继承
		B类继承A类，相当于对A类的功能进行扩展。如果不希望对A类进行扩展，可以给A类加关键字
		final控制不了能不能调用的问题
		实例变量如果没有手动赋值的话，系统会赋默认值（构造方法执行过程中赋值）
		final修饰的实例变量，系统不管赋默认值，要求程序员必须手动赋值
		结论：final修饰的实例变量，系统不负责赋默认值，要求程序员必须手动赋值。
		这个手动赋值，在变量后面赋值可以，在构造方法中赋值也可以
		实例变量在堆中，一个对象一份，100个对象100份
		实例变量既然使用final修饰了，说明该实例变量值不会随着对象的变化而变化
		final修饰的实例变量一般添加static修饰
		static final 修饰的变量称为常量
		常量名建议全部大写，每个单词之间采用下划线衔接
		常量和静态变量，都是存储在方法区，并且都是在类加载时初始化
		常量一般都是公开的（public）
		抽象类和接口以及抽象类和接口的区别：
			什么是抽象类：抽象类无法实例化，无法创建对象（类本身是不存在的，所以抽象类无法创建对象<实例化>）
			抽象类是类和类之间有共同特征，将这些具有共同特征的类进一步抽象，形成了抽象类
			由于类本身是不存在的，所以抽象类无法创建对象
			抽象类和抽象类实际上还会有共同特征，还可以进一步再抽象
			抽象类属于什么类型：引用数据类型
			抽象类怎么定义：
			语法：[修饰符列表] abstract class 类名{
				类体;
			} 
			抽象类是无法实例化的，无法创建对象的，抽象类是用来被子类继承的
			子类继承抽象类，子类可以继承对象
			abstract和final不能同时出现，这两个关键字是对立的
			抽象类的子类可以是抽象类
			抽象类虽然无法实例化，但是抽象类有构造方法（供子类使用）
			抽象方法关联到一个概念：抽象方法（没有实现的方法，没有方法体的方法）
		public abstract void dosome();
		抽象方法特点是什么：
		  没有方法体，以分号结尾
		  前面修饰符列表中有abstract关键字
		  抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类
		  重要结论：一个非抽象的类继承抽象类，必须将抽象类中的抽象方法实现了
		  <判断>：Java语言中凡是没有方法体的方法都是抽象方法（❌）
		  Object类中就有很多方法都没有方法体，都是以;结尾的，但他们都不是抽象方法 （底层调用c++）
	接口：
	1.接口是一种引用数据类型
	2.接口是完全抽象的（抽象类是半抽象）也可以说接口是特殊的抽象类
	接口编译之后也是.class文件
	基础语法：
	[修饰符列表] interface 接口名{
		
	}
	接口之间可以继承，支持多继承（可以继承多个接口）
	接口中只包含两部分内容，一部分是常量，一部分是抽象方法。没有其他内容了
	接口中所有的元素都是public修饰的，都是公开的
	接口中的抽象方法定义时，public abstract可以省略
	常量前边的public static final也可以省略，但是不能修改（被final修饰）
	接口抽象方法不能带有方法体，接口中的方法都是抽象方法
	类和类之间叫做继承，类和接口之间叫做实现
	继承使用extends，实现使用implements
	当一个非抽象的类实现接口的话，必须将接口中所有的抽象方法全部实现（覆盖、重写）
	接口和接口之间支持多继承，那么一个类可以同时实现多个接口吗：可以
	这种机制弥补了Java中的哪个缺陷：Java中类和类只支持单继承，实际上单继承是为了简单而出现的，现实世界中存在
	多继承，Java中的接口弥补了单继承带来的缺陷
	实现多个接口实际上就类似于多继承
	经过测试，接口与接口之间进行强制类型转换的时候，没有继承关系，也可以强转
	但是一定要注意，运行时可能会出现ClassCastException异常
	继承和实现都存在：
		extends在前，implements在后 
	接口在开发中的作用：
		类似于多态在开发中的作用
		多态：面向抽象编程，不要面向具体，降低程序耦合度，提高程序扩展力
		Cat is a Animal 但凡满足is a 的表示都可以设置为继承
		Customer has a Foofmenu，但凡是满足has a的表示都以属性的形式存在
		面向抽象编程，面向接口编程。降低程序耦合度，提高程序扩展力
		接口的使用离不开多态机制（接口+多态才可以降低耦合度）
		任何一个接口都有调用者和实现者
		接口可以将调用者和实现者解耦合
	抽象类和接口之间有什么区别：
			抽象类是半抽象的
			接口是完全抽象的
			抽象类中有构造方法
			接口中没有构造方法
			接口和接口之间支持多继承
			类和类之间只能单继承
			一个类可以同时实现多个接口
			一个抽象类只能继承一个类（单继承）
			接口中只允许出现常量和抽象方法
		package和import：
			1.为什么要使用package：package是Java中的包机制。包机制是为了方便程序的管理
			不同功能的类分别存放在不同的包下，不同的包存放的功能不同
			2.package怎么用：package是一个关键字，后边加包名：package com.bjpowernode.javase.chapter17;
			注意：package语句只允许出现在Java源代码的第一行
			3.包名有没有命名规范：一般都采用公司域名倒序的方式（公司域名具有全球唯一性）
			包名命名规范：公司域名倒序+项目名+模块名+功能名
			对于带有package的：
			编译：javac -d . HelloWorld.java
			javac 负责编译的命令
			-d  带包编译
			.  代表编译之后生成的东西放到当前目录下（点代表目录）
			
			运行：java package com.bjpowernode.javase.chapter17.HelloWorld;
		关于import的使用：不在同一个package下，包名不能省略
		 import什么时候时候用：A类中使用B类，A和B类都在同一个包下，不需要import
		 A和B不在同一个包下需要使用import
		 怎么用：import语句只能出现在package语句之下，class声明之上
		 完整类名带有包名
		 java.lang不需要包，同包下不需要，其他都需要
		 import 完整类名
		 import 包名.*
		 *只能省略具体的类名
		 import java.*这是不允许的
	访问控制权限：private（私有）、protected（受保护的）、public（公开）、默认
	   控制的范围：
	   private：私有的，只能在本类中访问
	   public：公开的，在任何位置都可以访问
	   protected：只能在本类、同包、子类下访问
	   默认：表示只能在本类以及同包下访问
		public>protected>默认>private
		访问控制权限可以修饰什么：
			属性（四个都可以）
			方法（四个都可以）
			类(public和默认)
			接口（public和默认）
		Object类中有哪些常用的方法：
		  去哪里找这些方法呢：第一种方法：去源代码中（这种方式比较麻烦，源代码比较难）
		  第二种：去查阅Java的类库的帮助文档
		    什么是API：应用程序编程接口
			整个JDK的类库就是一个javase的API
			每一个API都会配置一套API帮助文档
			toString（）方法的设计目的是：通过调用这个方法可以将一个“java对象转换成“字符串的表示形式””
			建议所有的子类都去重写toString（）方法
		equals（）方法：
		设计equals目的：以后要通过equals方法来判断两个对象是否相等
		equals方法是判断两个对象是否相等的
		MyTime t1 = new MyTime();
		MyTime t2 = new MyTime();
		System.out.println(t1 == t2);这里判断的是内存地址
		判断两个java对象是否相等，不能使用'=='，比较的是内存地址
		比较两个字符串能不能用双等号：不能，要使用equals
		结论：Java中基本数据类型比较是否相等，使用==
		Java中所有的引用数据类型统一使用equals方法来判断是否相等
	关于Object类中的finalize()方法：
		finalize（）方法只有一个方法体，里边没有代码，而且这个方法是protected修饰的
		这个方法不需要程序员手动调用，JVM垃圾回收器负责调用这个方法
		finalize执行时机：当一个Java对象即将被垃圾回收器回收的时候，垃圾回收器负责调用finalize（）这个方法
		finalize（）方法实际上是SUN公司为Java程序员准备的一个时机，垃圾销毁时机。如果希望在对象销毁时机执行一段代码的话，
		这段代码要写到finalize（）方法当中
		finalize（）只需要重写，重写完将来自动会有程序来调用
		Java中的垃圾回收器不是轻易启动的，垃圾太少或者时间没到，种种条件下有可能启动也有可能不启动
		System.gc（）：建议启动垃圾回收器
	hashCode方法：这个方法不是抽象方法，带有native关键字，底层调用c++程序
	返回哈希值
	实际上就是一个Java对象的内存地址，经过哈希算法，得出的一个值
	所以hashCode（）方法的执行结果可以等同看作一个java对象的内存地址
	内部类：在类的内部又定义了一个新的类
	内部类的分类：静态内部类：类似于静态变量
	实例内部类：类似于实例变量
	局部内部类：类似于局部变量
	匿名内部类属于局部内部类的一种
	使用内部类编写的代码可读性很差，尽量不用
	匿名内部类（没有名字的类）是局部内部类的一种
	匿名内部类两个缺点：太复杂、太乱，可读性差
	类没有名字，无法重复使用
	使用方法：new 接口名(){方法体}
	数组：
		1.Java语言中的数组是一种引用数据类型
		2.数组实际上是一个容器，可以容纳多个元素（数组是一个数据的集合）
		3.数组当中可以存储基本数据类型，也可以存储引用数据类型的数据
		4.数组因为是引用类型，数组对象是存储在堆内存当中
		5.数组当中如果存储的是“Java对象”的话，实际上存储的对象的“引用（内存地址）”，数组中不能直接存储对象
		6.数组一旦创建，在Java中规定 ，长度不可变
		7.数组的分类包括：一维数组、二维数组、多维数组....
		8.所有的数组对象都有length属性（Java自带），用来获取元素个数
		9.Java中的数组，要求数组中的元素类型统一
		10.数组在内存方面存储的时候，数组中的元素内存地址是连续的
		11.所有的数组都是拿第一个小方框的内存地址作为数组的内存地址
		12.数组中每一个元素都是有下标的，下标从0开始，以一递增。最后一个元素的下标是：length - 1
		13.数组的优点和缺点:
		  优点：查询/查找/检索某个下标上的元素时效率极高。可以说是查询效率最高的一个数据结构
		    为什么检索效率高：①每一个元素的内存地址在空间存储上是连续的
			②每一个元素类型相同，所以占用空间大小一样
			③知道第一个元素内存地址，知道每一个元素占用空间大小，又知道下标，所以通过一个数学表达式就可以计算出
			某个下标上元素的内存地址。直接通过内存地址定位元素，所以数组的检索效率是最高的
		  缺点：第一：由于为了保证数组中每个元素的内存地址连续，所以在数组上随机删除或者增加元素的时候效率较低，
		  因为随机增删元素会涉及到后面元素统一向前或者向后位移的操作
		  第二：数组不能存储大数据量：很难在内存空间上找到一块特别大的连续的内存空间
		  注意：对数组中最后一个元素的增删是没有影响的
		  14.怎么声明/定义一个一维数组：
			语法格式：int[] array1;
			double[] array2;
			boolean[] array3;
			String[] array4;
			Object[] array5;
			15.怎么初始化一个一维数组呢：
			  包括两种方式：静态初始化一维数组，动态初始化一维数组
		  静态初始化语法格式：int[] array = {100,2100,55};
		  动态：int array = new int[5];//这里的5表示数组的元素个数
		  //初始化一个5个长度的int类型数组，每个元素默认值为0
		  如果直接传递一个静态数组的话，语法：
		  printArray(new int[]{1,2,3})
		  main方法上边的String[] args有什么用：JVM调用main方法的时候，会自动传一个String数组过来
		  关于一维数组的扩容：
		  在Java开发中，数组长度一经确定不可变，数组如果满了，需要扩容
			Java对数组的扩容：先新建一个大容量数组，然后将小容量数组中的数据一个一个拷贝到大数组当中
			数组扩容效率较低，涉及到拷贝的问题，所以以后开发过程中注意尽可能少数组拷贝
		Java中数组拷贝：System.arraycopy(五个参数);
		二维数组：二维数组其实是一个特殊的一维数组，特殊在这个一维数组当中的每一个元素是一个一维数组
		方法的参数是二维数组：
		 int[][] a = {{1,2,3,4},{5,6},{7,8,90}};
		 printArray(a);
		 以下这种写法是错误的：
		 printArray({{1,2,3,4},{5,6},{7,8,90}});
		 可以这样写:printArray(new int[][] {{1,2,3,4},{5,6},{7,8,90}});
		 字符串"abc"这是一个字符串对象，不需要new也是一个对象
		 java.util.Arrays数组工具类
		 其中有一个静态方法sort（）可以直接排序
		冒泡排序算法：1.每一次循环结束之后，都要找出最大的数据，放到参与比较的这堆数据的最右边（冒出最大的气泡）
			2.核心：拿着左边的数字和右边的数字比对，当左边＞右边的时候，交换位置
			冒泡的外层循环：for(int i = arr.length;i>0;i++){
			内层循环：			for(int j = 0;j<i;j++){
			}	
			}
	选择排序：每一次从这堆参与比较的数据当中找出最小值
	拿着这个最小值和最前面的元素交换位置
	选择排序比冒泡排序好在：每一次的交换都是有意义的
	循环一次，然后找出参加比较的这堆数据中最小的，拿着这个最小值和最前面的数据交换位置
数组元素查找：第一种方式：一个一个挨着找，直到找到为止
第二种方式：二分法查找（算法），这个效率较高
二分法查找是基于排序的基础之上（没有排序的数据是无法查找的）
二分法查找效率高于一个挨着一个的查找方式
原理：10 23 56 89 100 111 222 235 500 600
目标：找出600下标
	（0 + 9） / 2 -->4（中间元素下标）
	arr[4]是中间元素：arr[4]是100
	100 < 600 说明被查找的元素在100右边
	此时开始下标变成 4 + 1 
	（5 + 9） / 2 = 7
	中间元素下标7
	arr[7]对应的值235
	235 < 600 说明被查找的元素在235的右边，此时开始下标进行转变
	7 + 1 = 8    (8 + 9) / 2 = 8
	arr[8] = 500 < 600
	开始元素下标变成8 + 1 = 9  （9 + 9） / 2 = 9
	arr[9] = 600与要找元素相等
	二分法查找的终止条件：一直折半，直到中间那个元素恰好是被查找的元素
	String类：java.lang.String
	1.String表示字符串类型，属于引用数据类型，不属于基本数据类型
	2.在Java中随便使用双引号括起来的都是String对象。例如："abc","def"
	3.Java中规定双引号括起来的字符串，是不可变的，也就是说"abc"自出生到最终死亡，不可变,不能变成"abcd"
	4.JDK中双引号括起来的字符串，例如:"abc""def"都是直接存储在方法区的"字符串常量池"当中的
	String s1 = "abc";
	s1里边保存的不是"abc"字符串，是字符串对象的内存地址
	String s1 = "hello";
	"hello"存储在方法区字符串常量池中
	所以"hello"不会新建（因为这个对象已经存在了）
	String s2 = "hello";
	s1 == s2 //true
	String s1 = new String("xyz");
	String s2 = new String("xyz");
	s1 == s2 //false
	垃圾回收器是不会释放常量池里的东西的
	String s1 = new String("abc");
	String s2 = new String("abc");
	一共创建了三个对象：字符串常量池一个，new堆内存两个
	String(字节数组，数组元素下标的起始位置，长度)
	可以将byte数组的一部分转换成对应ASCLL码组成的字符串
	String类当中常用方法：
		1.char charAt(int index) 取出字符串中下标为index的字符
		2.int compareTo(anotherArray)拿着字符串第一个字母和后边字符串第一个字母比较，能分胜负就不进行比较了
		3.boolean contains(CharSequence s)判断前面的字符串是否包含后边的字符串
		4.boolean endsWith(String suffix)判断当前字符串是否以某个字符串结尾
		5.boolean equalsIgnoreCase(String anotherString)判断两个字符串是否相等，同时忽略大小写
		6.byte[] getBytes()将字符串对象转换成字节数组
		7.int indexOf(String str)判断某个子字符串在当前字符串中第一次出现处的索引(下标)
		8.boolean isEmpty()判断某个字符串是否为空字符串
		******判断数组长度和判断字符串长度不一样
		判断数组长度是length属性，判断字符串长度是Length（）方法
		9.int lastIndexOf(String str)判断某个子字符串在当前字符串中最后一次出现的索引
		10.String replace(CharSequence target,CharSequence replacement)替换
		String的父接口就是CharSequence
		11.String[] split(String regex)拆分字符串
		12.boolean startsWith(String prefix)判断某个字符串是否以某个子字符串开始
		13.String substring(int beginIndex)截取字符串    参数是起始下标
		14.String substring(int beginIndex，int endIndex)截取字符串(左闭右开，截到beginIndex-1)
		15.char[] toCharArray()将字符串转换成char数组
		16.String toLowerCase()转换为小写
		17.String toUpperCase()转换为大写
		18.String trim()去除字符串前后空白
		19.String中只有一个方法是静态的，不需要new对象
		这个方法叫做valueOf      作用：将“非字符串”转换成“字符串”
		当参数是一个引用时，会自动调用toString()方法
		在实际开发中，如果要频繁进行字符串拼接，会有什么问题：
		Java中字符串是不可变的，每一次拼接都会产生新的字符串
		这样会占用大量的方法区内存，造成内存空间浪费
		StringBuffer底层实际上是一个byte[]数组，初始化容量为16
		往StringBuffer中放字符串，实际上是放到byte数组当中了
		StringBuffer stringbuffer = new StringBuffer()创建一个初始化容量为16个byte[]数组（字符串缓冲区对象）
		StringBuffer.append拼接字符串，以后拼接字符串统一调用append（）方法
		优化StringBuffer性能：创建StringBuffer时尽可能给定一个初始化容量
		最好减少底层数组的扩容次数，预估计给一个大一些的初始化
		StringBuffer和StringBuilder的区别：
		StringBuffer中的方法都有：synchronized关键字修饰。表示StringBuffer在多线程环境下运行是安全的
		StringBuilder中的方法都没有：synchronized关键字修饰 表示StringBuilder在多线程环境下运行是不安全的
	Java中为8种基本数据类型对应准备了8种包装类型。8种包装类属于引用数据类型，父类是Object
	为什么提供8种包装类：8种基本数据类型不够用
	基本数据类型-->引用数据类型（装箱）
	引用数据类型-->基本数据类型（拆箱）
	Integer x = 100;         自动装箱
	int y = x;         自动拆箱
	String为什么是不可变的：在源代码中，String类中有一个byte[]数组，这个byte[]数组采用了final修饰，因为数组一旦创建长度不可变，并且被final
	修饰的引用一旦指向某个对象后，不可再指向其他对象，所以String是不可变的
	StringBuffer/StringBuilder为什么是可变的：在源代码中，StringBuffer/StringBuilder内部实际上是一个byte[]数组，这个byte数组
	没有被final修饰，StringBuffer/StringBuilder的初始化容量是16，当存满之后会进行扩容，底层调用数组拷贝的方法System.arraycopy()
	是这样扩容的。所以StringBuffer/StringBuilder适合于字符串的频繁拼接操作
	字符串不可变是什么意思：双引号里面的字符串对象一旦创建，不可改变
	字符串类型的引用可以指向其他地方，存储在字符串常量池中的字符串不能改变
	自动装箱：基本数据类型自动转换成包装类
	自动拆箱：包装类自动转换成基本数据类型
	Integer a = 1000;
	        Integer b = 1000;
	        System.out.println(a == b);//false
	== 这个运算符不会触发自动拆箱机制
	只有+-*/等运算才会触发
	在byte取值范围-128~127之间使用integer时，会自动调用byte常量池，不再重新new对象
	Integer a = 127;
	        Integer b = 127;
	        System.out.println(a == b);//true
	        Integer x = 128;
	        Integer y = 128;
	        System.out.println(x == y);//false
			Java中为了提高程序执行效率，将-128~127之间所有的包装对象提前创建好，放到方法区的整数型常量池中，
			目的是只要用这个区间的数据不需要new了，直接从整形常量池中取出来
			重点方法：static int parseInt(String s)
			静态方法，传参String，返回int
			static String toBinaryString(int i)
			静态的：将十进制转换成二进制字符串
			static String toHexString(int i)
			静态的：将十进制转换成十六进制字符串
			static String toOctalString(int i)
			静态的：将十进制转换成八进制字符串
		valueOf方法：
			static Integer valueOf(int i)
			静态的：int --> Integer
			static Integer valueOf(String s)
			静态的：String --> Integer
			String-->int:Integer.parseInt()
			int --> String:String.valueOf()/数字+""
			Integer --> int :自动拆箱intValue方法
			int --> Integer：自动拆箱Integer.valueOf()
			String-->Integer:Integer.valueOf("")
			Integer --> String:String.valueOf(Integer对象)
		java中对日期的处理：获取系统当前时间（精确到毫秒的系统当前时间）
		直接调用无参数构造方法就行
		Date nowtime = new Date;
		日期可以格式化吗：将日期类型Date，按照指定的格式进行转换：Date -- 转换成具有一定格式的日期字符串-->String
		   SimpleDateFormat是java.text包下的，专门负责日期格式化的
		   假设现在有一个日期字符串String，怎么转换成Date类型：SimpleDateFormat sdf = new SimpleDateFormat("格式不能随便写，要和日期字符串格式相同");
		   Date datetime = sdf.parse(time);
			简单总结一下System类的相关属性和方法：
			System.out 【out是System类的静态变量】
			System.out.println()【println()方法不是System类的，是PrintStream类的方法】
			System.gc()建议启动垃圾回收器
			System.exit(0) 退出JVM
		数字格式化：DecimalFormat df = new DecimalFormat();//参数为一个数字格式
		数字格式有哪些：# 代表任意数字
		, 代表千分位
		.代表小数点
	BigDecimal属于大数据，精度极高。不属于基本数据类型，属于java对象（引用数据类型）
	这是SUN公司提供的一个类，专门用在财务软件当中
	注意：财务软件中double是不够用的
	随机数：Random rd = new random();
	rd.nextInt()产生随机数
	rd.nextInt(101)产生一个[0~100]之间的随机数不能产生101
	Enum枚举：
		在开发中有可能遇到一个方法的执行结果可能包含三种情况，四种情况，五种情况不等，但是每一个都是可以可以数清楚的，
		一枚一枚都是可以列举出来的。这个布尔类型就无法满足需求了。此时需要使用java语言中的枚举类型
		enum枚举编译之后也是生成class文件
		枚举也是一种引用数据类型
		枚举中的每一个值可以看作是常量
		总结：1.枚举是一种引用数据类型
		2.枚举类型定义：enum 枚举类型名{
			枚举值1，枚举值2
		}
		3.结果只有两种情况的，建议使用布尔类型，结果超过两种并且可以一种一种列举出来的，建议使用枚举
		例如：颜色、星期、四季
		switch语句支持枚举类型、String、int
		byte short char也可以，存在自动类型转换
		低版本JDK只支持int
	异常处理：程序执行过程中发生了不正常的情况，而这种不正常的情况叫做：异常
		程序执行控制台输出的错误信息被称为异常信息，是JVM打印的
		异常作用：增强程序的健壮性
		java语言中异常以类的形式存在，每一个异常类都可以创建异常对象
		UML以及starUML：什么是UML，有什么用：UML是一种统一建模语言，一种图标式语言（画图的）
		在UML图中可以描述类和类之间的关系，程序执行的流程，对象的状态等
		所有Exception的直接子类都叫编译时异常，RuntimeException运行时异常
		运行时异常在编写程序阶段可以选择处理，也可以选择不处理
		编译时异常不是在编译阶段发生的 编译时异常是表示必须在编写程序的时候预先对这种异常进行处理，如果不处理编译器报错
		编译时异常和运行时异常都是发生在运行阶段。编译阶段异常是不会发生的
		编译时异常为什么而得名：因为编译时异常必须在编译（编写）阶段预先处理，如果不处理编译器报错，因此得名
		异常的发生就是new异常对象
		编译时异常一般发生的概率比较高，运行时异常一般发生的概率比较低
		编译时异常又被称为受检异常或受控异常
		运行时异常也叫未受检异常，或者非受控异常
	java处理异常的两种方式：
		第一种方式：在方法声明的位置上，使用throws关键字，抛给上一级
		第二种方式：使用try..catch语句进行异常的捕捉
		异常发生之后，如果选择上抛，抛给调用者，调用者需要对这个异常继续处理，那么调用者处理这个异常同样有两种处理方式
		注意：Java中异常发生之后如果一直上抛，最终抛给了main（）方法，main方法继续向上抛，抛给了调用者JVM，JVM知道这个异常发生
		只有一个结果：终止java程序的执行
		抛FileNotFoundException的父对象IOException是可以的，因为IOException包括FileNotFoundException
		一般不建议在main()方法上使用throws，因为这个异常如果真的发生了，一定会抛给JVM。JVM只有终止
		异常处理机制的作用是增强程序的健壮性
		一般main（）方法的异常建议使用try...catch进行捕捉。main就不要继续上抛了
		如果某块代码出现异常，后面的代码无法执行
		catch后面是一个方法的形参。这个分支中可以使用e引用，e引用保存的内存地址是那个new出来的异常对象的内存地址
		注意：只要异常没有捕捉，采用上报的方式，此方法的后续代码不会执行
		try语句块中某一行代码出现异常，改行后边的代码不会执行
		深入try..catch
			1.catch后面的小括号中的类型可以是具体的异常类型，也可以是该异常类型的父类型
			2.catch可以写多个。建议catch的时候，精确的一个一个处理，这样有利于程序的调试
			3.自上到下异常的范围应该越来越大，否则上边已经捕捉过大范围异常，下边的语句不执行
			4.JDK8新特性：允许在catch的小括号中采用“或”（'|'）来捕捉多个异常
			以后开发中，如果异常需要调用者来处理，采用throws，其他情况采用捕捉的方式
			异常对象有两个非常重要的方法：
				获取异常简单的描述信息：
				String msg = exception.getMessage();
				打印异常追踪的堆栈信息：
				exception.peintStackTrace();
			异常追踪信息，从上往下一行一行看
		关于try..catch中的finally子句：
			1.在finally子句中的代码是最后执行的，并且一定会执行，即使try语句块中的代码出现了异常
			finally子句必须和try一起出现，不能单独编写
			2.finally语句通常使用在哪些情况下：
			读文件之后文件被打开，如果使用过程中发生了一场，而在异常之后关闭文件的语句将不会执行，这是非常危险的，
			使用finally语句执行文件的关闭语句
			通常在finally语句块中完成资源的释放/关闭
			因为在finally中的代码比较有保障
			即使try语句块中的代码出现异常，finally中的代码也会正常执行
			try和catch可以没有catch
			try{
			            System.out.println("hello");
			            return;
			        }finally {
			            System.out.println("execute");
			        }
					输出结果为：hello	execute
					代码执行顺序：先执行try中打印代码，检测到return，去执行finally子句中的代码，然后再去return
		java中有这样的规则：①方法体中的代码必须遵循自上而下顺序依次逐行执行
		②return语句一旦执行，整个方法必须结束
		public static int m1() {
		        int i = 0;
		        try{
					这行代码出现在int i = 0的下边，所以最终结果必须是0
		            return i;
		        }finally {
		            i++;
		        }
		    }
			返回i的值是0
	final finally和finalize有什么区别：final是一个关键字，表示最终的、不变的
	finally也是一个关键字，和try联合使用，使用在异常处理机制中
	在finally语句块中的代码是一定会执行的
	finalize（）是Object类中的一个方法，作为方法名出现，是一个标识符
	java中怎么自定义异常呢：
		第一步：编写一个类继承Exception或者RuntimeException
		第二步：提供两个构造方法，一个无参数的，一个带有String参数的
	在方法中自定义异常使用try..catch没有意义，相当于自己new一个异常，自己捉。异常信息要传递出去
	总结异常中的关键字：try、catch、finally、throws、throw
		引用等于null的判断最好放在所有条件的最前边
		username==null不如写成null==username：防止写成username=null
		类强制类型转换转成接口类型时不需要有继承关系
	集合概述：
		什么是集合，有什么用：数组其实就是一个集合。集合实际上是一个容器，可以来容纳其他类型的数据
		集合为什么在开发中使用较多：集合是一个容器，是一个载体，可以一次容纳多个对象。
		在实际开发中，假设连接数据库，数据库当中有十条记录，那么假设把这十条记录查询出来，在java程序中会将十条数据
		封装成10个java对象，然后将10个java对象放到某一个集合当中，将集合传到前端，然后遍历集合，将一个数据一个数据展现出来
		集合中不能直接存储基本数据类型，另外集合也不能直接存储java对象
		集合当中存储的都是java对象的内存地址（或者说集合中存储的是引用）
		注意：集合在java中本身是一个容器，是一个对象
		集合中任何时候存储的都是引用
		集合也是一个对象，有内存地址
		在java中每一个不同的集合，底层会对应不同的数据结构。往不同的集合中存储元素，等于将数据放到了不同的数据结构当中
		不同的数据结构，数据存储的方式不同 数组、二叉树、链表、哈希表
		new ArrayList(); 创建一个集合，底层是数组
		new LinkedList(); 创建一个集合对象，底层是双向链表
		new TreeSet(); 创建一个集合对象，底层是二叉树
		集合在java.util.*包下
		所有的集合和接口都在这个包下
		在java中集合分为两大类：一类是单个方式存储元素
		这一类集合中超级父接口：java.util.Collection
		一类是以键值对的方式存储元素
		这一类集合中超级父接口：java.util.Map
		所有集合继承Iterable的含义是：所有集合都是可迭代的
		List集合存储元素特点：有序可重复，存储的元素有下标
		有序实际上是说存进去是这个顺序，取出来还是这个顺序
		这里的顺序不是说按照大小排序
		有序是因为List集合都有下标，下标从0开始，递增
		Set集合无序不可重复
		无需表示存进去是这个顺序，取出来就不一定是这个顺序了
		另外Set集合中的元素没有下标，元素不能重复
		ArrayList集合底层采用了数组这种数据结构
		ArrayList集合是非线程安全的
		LinkedList集合底层采用了双向链表数据结构
		Vector集合底层采用了数组这种数据结构
		Vector集合是线程安全的
		Vector所有的方法都有synchronized关键字修饰，所以线程安全，但是效率较低
		实际上HashSet集合在new的时候，底层实际上new了一个HashMap集合
		向HashSet集合存储元素，实际上是存储到了HashMap中了。HashMap集合是一个哈希表数据结构
		实际上TreeSet集合在new的时候，底层实际上new了一个TreeMap集合
		向TreeSet集合存储元素，实际上是存储到了TreeMap中了。TreeMap底层采用二叉树数据结构
		SortedSet集合存储元素的特点：由于继承了Set集合，所以它的特点也是无序不可重复，但是放在SortedSet集合中的元素可以自动排序，称为可排序集合
		放到该集合中的元素是自动按照大小顺序排列的
		Map集合和Collection集合没有关系
		Map集合以key和value这种键值对的方式存储元素
		key和value都是存储java对象的内存地址
		HashMap集合底层是哈希表数据结构，是非线程安全的
		Hashtable底层也是哈希表，是线程安全的，效率较低，现在使用较少，控制线程有其他更好的方案
		所有Map集合的key特点：无序不可重复
		Map集合的key和Set集合存储元素的方式相同
		SortedMap集合的key元素特点：首先是无序不可重复的，另外放在SortedMap集合key部分的元素
		会自动按照大小顺序排序，称为可排序的集合
		Properties是线程安全的，因为继承Hashtable，存储元素的时候也是采用key和value的形式存储，并且key和value只支持String类型，不支持其他类型
		Properties被称为属性类
		总结：ArrayList：底层是数组
		LinkedList：底层是双向链表
		Vector：底层是数组，线程安全的，效率较低，使用较少
		HashSet：底层是HashMap，放到HashSet集合中的元素等同于放到HashMap集合key部分了
		TreeSet：底层是TreeMap，放到TreeSet集合中的元素等同于放到TreeMap集合key部分了
		HashMap：底层是哈希表
		Hashtable：底层也是哈希表，只不过是线程安全的，效率较低，使用较少
		Properties：线程安全的，并且key和value只能存储字符串String
		TreeMap：底层是二叉树。TreeMap集合的key可以自动按照大小顺序排序
		List集合存储元素的特点：有序可重复
			有序：存进去的顺序和取出的顺序相同，每一个元素都有下标
			可重复：存进去一个1，还可以再存一个1
		Set（Map）集合存储元素的特点：无序不可重复
		无序：存进去的顺序和取出的顺序不一定相同，另外Set集合中元素没有下标
		不可重复：存进去一个1，就不能再存1了
		SortedSet（SortedMap）集合存储元素特点：
				首先是无序不可重复的，但是SortedSet集合中的元素是可排序的
				无序：存进去的顺序和取出的顺序不一定相同，另外Set集合中元素没有下标
				不可重复：存进去一个1，就不能再存1了
				可排序：可以按照大小顺序排列
		Map集合的key，就是一个Set集合
		1.Collection中能存放什么元素：没有使用“泛型”之前，Collection中可以存储Object的所有子类型
		使用了“泛型”之后，Collection中只能存储某个具体的类型
		集合中不能直接存储基本数据类型，也不能存java对象，只能存储java对象的内存地址
		2.常用方法：boolean add(E e)向集合中添加元素
		int size()  获取集合中元素个数
		void clear()  清空集合
		boolean contains(Object o)  判断当前集合是否含有元素o，包含返回true，不包含返回false
		删除集合中某个元素 remove()方法
		判断集合是否为空：isEmpty()
		Object[] toArray()  调用这个方法可以把集合转换成数组
		以下的遍历方式/迭代方式，是所有Collection通用的一种方式
		在Map集合中不能用，在所有的Collection以及子类中使用
		对集合Collection进行遍历/迭代
		第一步：获取集合对象的迭代器对象Iterator
		第二步：通过以上获取的迭代器对象开始迭代/遍历集合
		以下两个方法是迭代器对象Iterator中的方法
		boolean hasNext() 如果仍有元素可以迭代，则返回true
		Object next() 返回迭代的下一个元素
		迭代器对象it：负责遍历/迭代集合当中元素的
		注意：迭代器对象最初并没有指向第一个元素
		boolean hasNext = it.hasNext();
		这个方法返回true，表示还有元素可以迭代，这个方法返回false表示没有更多的元素可以迭代了
		Object obj = it.next();
		这个方法让迭代器前进一位，并且将指向的元素返回
		存放在一个集合中的方法，一定要重写equals
		remove中重写了equals
		在比较中调用的equals不是集合的equals，是对象的equals
		集合结构只要发生改变，迭代器必须重新获取
		直接通过集合去删除元素，没有通知迭代器（导致迭代器的快照和原集合状态不同）
		出异常的根本原因是：集合中元素删除了，但是没有更新迭代器（迭代器不知道集合变化了）
		ArrayList集合：默认初始化容量10（底层先创建了一个长度为0的数组，当添加第一个元素的时候，初始化容量10）
		ArrayList集合扩容：是原来的1.5倍
		尽可能少扩容，因为数组扩容效率较低，建议预估计元素个数，给定初始化容量
		Vector扩容之后是原容量二倍
		将一个非线程安全的变为线程安全的：
		调用java.util.Collections中的方法
		Collections.synchronizedList(myList);
		之后使用myList集合就是线程安全的
		泛型属于编译阶段的新特性
		好处：1.集合中存储的元素类型统一了
		2.从集合中取出的元素是泛型指定的类型，不需要大量“向下转型”
		缺点：导致集合中存储的元素缺乏多样性
		调用子类型特有的方法还是需要向下转换的
		JDK8之后引入了：自动类型推断机制（又称为钻石表达式）
		自定义泛型时，<>中的是一个标识符，可以随便写
		遍历集合的第二种方法:Set<Map.Entry<K,V>> entrySet()
		上面这个方法是将Map集合直接全部转换成Set集合
		Set集合元素类型是Map.Entry
		map.put(k,v)实现原理：
		 第一步：先将k，v封装到Node对象当中
		 第二步：底层会调用k的HashCode()方法得出hash值，然后通过哈希函数/哈希算法，将hash值转换成数组的下标，
		 下标位置上如果没有任何元素，就把Node添加到这个位置上。如果下表对应的位置有链表，此时会拿着k和链表上每一个
		 节点中的k进行equals，如果所有的equals方法返回都是false，那么这个新结点将被添加到链表的末尾。如果其中有一个equals返回了true，那么这个节点的value将会被覆盖
		哈希表使用不当时无法发挥其性能！
		假设将所有的hashCode()方法返回值固定为某个值，那么会导致底层的哈希表变成了纯单向链表。这种情况称为散列分布不均匀
		什么样散列分布均匀：假设有100个元素，10个单向链表，那么每个单向链表上有10个节点，这是最好的，是散列均匀的
		假设将所有的hashCode()方法返回值都设定为不一样的值，有什么问题：这样的话导致哈希表成为一维数组，没有链表的概念了，也就是散列分布不均匀
		HashMap集合的默认初始化容量是16，默认加载因子是0.75
		默认加载因子是当HashMap集合底层数组的容量达到75%的时候，数组开始扩容
		Hashmap集合初始化容量必须是2的倍数
		如果equals方法返回true，hashCode()方法返回的值必须一致
		放在HashMap集合key部分的，以及放在HashSet集合中的元素，需要同时重写hashCode方法和equals方法
		HashMap底层是哈希表数据结构，是非线程安全的。在JDK8之后，如果哈希表单向链表中元素超过8个，单向链表这种数据结构会变成红黑树数据结构。
		当红黑树上的节点数量小于6时，会重新把红黑树变成单向链表数据结构（为了提高检索效率）
		对于哈希表数据结构来说：如果o1和o2的hash值相同，一定是放在同一个单向链表上
		当然如果o1和o2的hash值不同，但由于哈希算法执行结束之后转换的数组下标可能相同，此时会发生"哈希碰撞"
		Hashtable的key和value都是不能为null的
		HashMap集合的key和value都是可以为null的
		放在TreeSet集合中的元素需要实现java.lang.Comparable接口
		并且实现compareTo方法。equals可以不写
		姓名是String类型，可以直接比。调用compareTo来完成比较
		TreeSet集合/TreeMap集合采用的是中序遍历方式
		iterator迭代器采用的是中序遍历方式
	结论：
		放到TreeSet或者TreeMap集合key部分的元素要想做到排序，有两种方式：
		第一种：放在集合中的元素实现java.lang.Comparable接口
		第二种：在构造TreeSet或者TreeMap集合的时候给它传一个比较器对象
		Comparable和Comparator怎么选择：当比较规则不会发生改变的时候，或者说当比较规则只有一个的时候，建议实现Comparable接口
		如果比较规则有多个，并且需要多个比较规则之间频繁切换，建议使用Comparator接口
		Comparator接口的设计符合ocp原则
		Collections要进行sort排序，必须要在自定义类型中实现Comparable方法
	多线程：
		进程可以看作现实生活当中的公司
		线程可以看作公司当中的某个员工
		进程A和进程B内存独立不共享
		线程A和线程B：在Java语言中线程A和线程B，堆内存和方法区内存共享
		栈内存独立
		使用了多线程机制之后，main方法结束，是不是有可能程序也不会结束，main方法结束只是主线程结束了，主栈空了，其他的栈（线程）可能还在
		压栈弹栈
		分析问题：对于单核CPU来说，真的可以真正做到多线程并发吗：
		   对于多核的CPU电脑来说，真正的多线程并发是没有问题的。
		   4核CPU表示同一时间点上，可以真正的有4个进程并发执行
			什么是真正的多线程并发：t1线程执行t1的
			t2线程执行t2的
			t1不会影响t2，t2也不会影响t1，叫做真正的多线程并发
			单核的CPU表示只有一个大脑
			对于单核的CPU来说，在某一个时间点上，只能处理一件事情，但是由于CPU处理速度极快，多线程之间频繁切换执行，给人的感觉是多个事情同时在做
			java中实现线程有两种方式：
				第一种方式：编写一个类，直接继承java.lang.Thread，重写run方法
				创建线程对象：new
				怎么启动线程：调用线程对象的start方法
				start方法的作用是：启动一个分支线程，在JVM中开辟一个新的栈空间，这段代码任务完成之后，瞬间就结束了
				这段代码的任务只是为了开辟一个新的栈空间，只要新的栈空间开出来，start方法就结束了，线程就启动成功了
				启动成功的线程会自动调用run方法，并且run方法在分支栈的栈底部，main方法在主栈的栈底部，run和main是平级的
				如果直接调用run方法，就不会启动线程，不会分配新的分支栈
				
				
				第二种方式：编写一个类，实现java.lang.Runnable接口，实现run方法
				第二种方式实现接口比较常用，因为一个类实现了接口，它还可以去继承其他的类，更灵活
		就绪状态的线程又叫做可运行状态，表示当前线程具有抢占CPU时间片的权力
		（CPU时间片就是执行权）
		当一个线程抢夺到CPU时间片之后，就进入运行状态
		run方法的开始执行标志着线程进入运行状态，当之前占有的CPU时间片用完之后，会重新回到就绪状态继续抢夺CPU时间片，当再次抢到CPU时间片之后，
		会重新进入run方法接着上一次的代码继续往下执行
		阻塞状态：遇到阻塞事件
		当一个线程遇到阻塞事件，例如接收用户键盘输入，或者sleep方法等，此时线程会进入阻塞状态，阻塞状态的线程会放弃之前占有的CPU时间片
		阻塞解除，会进入就绪状态继续抢夺CPU时间片，之前的时间片没了。
		关于线程对象的生命周期：新建状态、就绪状态、运行状态、阻塞状态、死亡状态
		run()当中的异常不能throws，只能try catch，子类不能比父类抛出更多的异常
		sleep是静态方法，引用.sleep本质上还是在当前线程中sleep，与引用是什么无关
		叫醒一个正在睡眠的线程:
			注意：这个不是中断线程的执行，是终止线程的睡眠
		在什么时候数据在多线程并发环境下会存在安全问题呢：三个条件：
			条件一：多线程并发
			条件二：有共享数据
			条件三：共享数据有修改行为
		如何解决：线程排队执行，不能并发
			用排队执行解决线程安全问题
			这种机制被称为：线程同步机制
			专业术语叫做线程同步，实际上就是线程不能并发了，线程必须排队执行
			线程同步就是线程排队，会牺牲一些效率，数据安全是第一位
		异步编程模型：线程t1和线程t2，各自执行各自的，t1不管t2，t2不管t1，谁也不需要等谁，这种编程模型叫做：异步编程模型
		其实就是：多线程并发
		同步编程模型：线程t1和线程t2，在线程t1执行的时候，必须等待t2线程执行结束，或者说在t2线程执行的时候，
		必须等待t1线程执行结束，两个线程之间发生了等待关系，就是同步编程模型。效率较低，排队执行
		线程同步机制语法：
		  synchronized(){
			  线程同步代码块
		  }
		 括号中必须是线程共享的数据，才能达到多线程排队
		 （）中写什么要看想让哪些线程同步，假设t1，t2，t3，t4，t5
		 只希望t1，t2，t3排队，一定要在小括号中写一个t1，t2，t3共享的对象
		 而这个对象对于t4，t5来说不共享的
	synchronized执行原理：
		1.假设t1和t2线程并发，开始执行以下代码的时候，肯定有一个先一个后
		2.假设t1先执行了，遇到了synchronized，这个时候自动找“后面共享对象”的对象锁，找到之后，并占有这把锁，然后执行同步代码块中的程序，
		在程序执行过程中一直都是占有这把锁的。直到同步代码块代码结束后，这把锁才会释放
		3.假设t1已经占有这把锁，此时t2也遇到synchronized关键字，也会去占有后边共享对象的这把锁，结果这把锁被t1占有，t2只能在同步代码块外边等待t1的结束，
		直到t1把同步代码块执行结束了，t1会归还这把锁，此时t2终于等到这把锁，然后t2占有这把锁之后，进入同步代码块执行程序
		这里要注意的是：这个共享对象一定要选好了。这个共享对象一定是你需要排队执行的这些线程对象所共有的
		括号中必须传共享对象，不能是局部对象
		如果括号中放一个字符串常量，所有线程都会同步
		java中三大变量：
			实例变量：在堆中
			静态变量：在方法区
			局部变量：在栈中
		以上三大变量中：局部变量永远都不会有线程安全问题
		（局部变量不共享）
		synchronized出现在实例方法中，锁的一定是this，只能是this
		所以这种方式不灵活
		另外还有一个缺点：synchronized出现在实例方法上，表示整个方法体都需要同步，可能会无故扩大程序的范围，导致程序执行效率降低
		优点：代码写得比较少，节俭了
		如果使用局部变量的话，建议使用StringBuilder
		因为局部变量不存在线程安全问题，选择StringBuilder
		StringBuffer比StringBuilder效率低
		synchronized第三种写法：在静态方法上使用synchronized
		表示找类锁
		类锁永远只有一把，就算创建了一百个对象，那类锁也只有一把
		对象锁：1个对象1把锁，100个对象100把锁
		类锁：100个对象，也可能只是一把类锁
		死锁：不出现异常，也不出现错误
		synchronized尽量不要嵌套使用，容易发生死锁
		以后如何解决线程安全问题：synchronized会让程序执行效率降低，用户体验不好，系统的用户吞吐量降低，用户体验差。
		在不得已的情况下再选择线程同步机制
		第一种方案：尽量使用局部变量代替实例变量和静态变量
		第二种方案：如果必须是实例变量，可以考虑创建多个对象，这样对象内存就不共享了
		第三种方案：如果不能使用局部变量，对象也不能创建多个，这时只能用synchronized
		守护线程的特点：一般守护线程是一个在死循环，所有的用户线程只要结束，守护线程自动结束
		实现线程的第三种方式：实现callable接口（jdk8新特性）
			这种方式实现的线程可以获取线程的返回值
			之前讲解的那两种无法获取线程的返回值，因为run方法返回void 
			get方法的执行会导致当前线程的阻塞，因为想要拿到执行结果，就必须要等待线程执行结束
			wait方法和notify方法作用：
				wait方法：Object o =  new Object();
							o.wait;
							表示：让正在o对象上活动的线程进入等待状态，无限期等待，直到被唤醒为止
							o.wait;方法的调用，会让“当前线程（正在o上活动的线程）”进入等待状态
				notify方法：Object o =  new Object();
							o.notify;
							表示：唤醒正在o对象上等待的线程
							wait方法和notify方法建立在synchronized线程同步的基础之上
				重点：o.wait（）方法会让正在o对象上活动的当前线程进入等待状态，并且释放之前占有o对象的锁
				notify方法只会通知，不会释放锁
				
		文件IO：
		java IO流四大家族：
		java.io.InputStream		字节输入流
		java.io.OutputStream		字节输出流
		java.io.Reader		字符输入流
		java.io.Writer		字符输出流
		注意：在java中只要类名以“Stream”结尾的都是字节流，以“Reader/Writer”结尾的都是字符流
		四大家族的首领都是抽象类
		所有的流都是可关闭的，都实现了closeable接口，都是可关闭的，都有close()方法。流毕竟是一个管道，这个是内存和硬盘之间的通道，用完之后一定要关闭
		所有输出流都实现了：java.io.flushable接口，都是可刷新的，都有flush（）方法，输出流在最终输出之后，一定要记得flush（）刷新一下
		这个刷新表示将通道/管道之中剩余未输出的数据强行输出完（清空管道）
		如果没有flush，可能会导致丢失数据
		javaio下需要掌握的流：
	    文件专属：
			java.io.FileInputStream
			java.io.FileOutputStream
			java.io.FileReader
			java.io.FileWriter
		转换流（将字节流转换成字符流）：
			java.io.InputStreamReader
			java.io.OutputStreamWriter
		缓冲流专属：
			java.io.BufferedReader
			java.io.BufferedWriter
			java.io.BufferedInputStream
			java.io.BufferedOutputStream
		数据流专属：
			java.io.DataInputStream
			java.io.DataOutputStream
		标准输出流：
			java.io.PrintWriter
			java.io.PrintStream
		对象专属流：
			java.io.ObjectInputStream
			java.io.ObjectOutputStream
		IDEA的默认当前路径：工程project的根就是IDEA的默认当前路径
		往read方法中传一个byte数组，一次读取数组.length个字节，返回值是读取的字节数量
		byte[] bytes = new byte[fis.available()];
			上边这种方式不适合大文件，因为byte数组不能太大
			写文件文件不存在时会自动新建
		当一个流的构造方法中需要一个流的时候，传进来的这个流叫做节点流
		外部负责包装的这个流，叫做包装流，还有一个名字叫作：处理流
		java.io.DataOutputStream：数据专属的流
		这个流可以将数据连同数据的类型一并写入文件
		注意：这个文件不是普通文本文档（使用记事本打不开）
		java.io.PrintStream:标准的字节输出流，默认输出到控制台
		标准输出流不需要手动close（）关闭
	File
		1.File类和四大家族没有关系，所以File类不能完成文件的读和写
		2.File对象代表什么：文件和目录路径名的抽象表示形式
		C:\Drivers 这是一个File对象
		一个File对象有可能对应的是目录，也可能是文件
		File只是一个路径名的抽象表现形式
		序列化（serialize）：拆分对象    java对象存储到文件中，将java对象保存下来
		反序列化（Deserialize）：组装对象    将硬盘上的数据重新恢复到内存当中，恢复成java对象
		参与序列化和反序列化的对象必须实现Serializable接口
		注意：通过源代码发现，Serializable接口只是一个标志接口，这个接口当中什么代码都没有
			作用：起到标识的作用
			java虚拟机看到这个类实现了这个接口可能会对这个类进行特殊待遇
			Serializable这个标志接口是给java虚拟机参考的，java虚拟机看到这个接口之后会为该类自动生成一个序列化版本号
			一次序列化多个对象：将对象放到集合当中，序列化集合
			transient关键字表示：游离的，不参加序列化
			被transient修饰的元素不参与序列化
		java语言区分类的机制：
			第一：首先根据类名
			第二：如果类名一样，靠序列化版本号进行区分
		自动生成的序列化版本号缺点：一旦代码确定之后，不能进行后续的修改，一旦修改，必然会重新编译，此时会生成全新的序列化版本号，
		这时java虚拟机会生成一个新的序列化版本号，JVM会认为这是一个全新的类
		结论：凡是一个类实现了Serializable接口，建议给该类提供一个固定不变的序列化版本号
		这样以后这个类即使代码修改了，但是版本号不变，java虚拟机会认为是同一个类
		建议手动写出来，不建议自动生成
		可以调用properties的load方法将文件中的数据加载到Map集合当中
		以后经常改变的数据，可以单独放一个文件中，使用程序动态读取
		将来只要修改这个文件的内容，java代码不需要改动，不需要重新编译，不需要重启，就能拿到动态信息
		类似于这样的文件，叫做配置文件
		并且当配置文件中内容是：key=value的时候，我们把这种配置文件叫属性配置文件
		建议以.properties结尾，称为属性配置文件
		其中Properties是专门存放属性配置文件内容的一个类
		在属性配置文件中#是注释
	反射机制：
		作用：通过java语言中的反射机制可以操作字节码文件（可以读和修改字节码文件）
		怎么获取类的字节码：
			三种方式：
				第一种：Class.forName()
					1.静态方法
					2.方法的参数是一个字符串
					3.字符串需要的是一个完整类名
					4.完整类名必须含有包名（java.lang也不能省略）
				第二种：java中任何一个对象都有getClass方法
					String s = "123";
					Class x = s.getClass; //x代表String.class字节码文件，x代表String类型
					这样拿到的x与第一种方法传参java.lang.String拿到的结果一样
				第三种：java语言中任何一种数据类型，包括基本数据类型，都有.class属性
				newInstance方法底层会调用无参构造进行对象创建
				反射机制灵活性：java代码写一遍，在不改变java源代码的基础之上，可以做到不同对象的实例化，非常灵活
				Class.forName()这个方法的执行会导致类加载，静态代码块执行
				凡是在src路径下的，都叫类路径（src是类的根路径）
				getContextClassLoader() 是线程对象的方法，可以获取到当前线程的类加载器对象
				getResource（）这是类加载器对象的方法，当前线程的类加载器默认从类的根路径下加载资源
			注解：或者叫做注释，英文单词annotation
				是一种引用数据类型，编译之后也是生成xxx.class文件
				自定义注解：
					[修饰符列表] @interface 注解类型名
				注解怎么使用，用在什么地方：
					第一：使用时语法格式：@注解类型名
					第二：注解可以出现在类上、方法上、属性上、变量上等
					注解还可以出现在注解类型上
				JDK内置注解：override注解只能注解方法，是给编译器参考的，和运行阶段没有关系
				凡是方法带有这个注解的，编译器检查，如果不是重写父类的方法，编译器报错
				注解注解的注解叫做元注解
				常见的元注解：Target  Retention
				Target注解用来标注“被标注的注解”可以出现在哪些位置上
				@Target(ElementType.METHOD):表示“被标注的注解”只能出现在方法上
				Retention注解用来标注“被标注的注解”最终保存在哪里
				@Retention(RetentionPolicy.SOURCE)：表示该注解只被保留在java源文件中
				@Retention(RetentionPolicy.CLASS)：表示该注解被保留在class文件中
				@Retention(RetentionPolicy.RUNTIME)：表示该注解被保留在class文件中，并且可以被反射机制读取
				在注解当中可以定义属性
				报错原因：如果一个注解当中有属性，那么必须给属性赋值，除非该属性使用了default赋值
				解决：@注解(属性名=属性值)
				属性名是value时可以省略（只能有一个属性时使用，如果有多个属性，不能省略）
				属性的类型可以是：byte short int long float double boolean char String Class 枚举类型，以及它们的每一种数组形式
				
				
				
					
		
		
		
	
	
	